package repeat;
/*
 * Доска состоит из сетки m x n ячеек, где каждая ячейка имеет начальное состояние: 
 * живая (представлена ​​1) или мертвая (представлена ​​0). 
 * Каждая ячейка взаимодействует со своими восемью соседями 
 * (горизонтальная, вертикальная, диагональная) с использованием следующих четырех правил:
 * 
 * Любая живая клетка с менее чем двумя живыми соседями умирает, как будто из-за недонаселения.
 * Любая живая клетка с двумя или тремя живыми соседями живет в следующем поколении.
 * Любая живая клетка с более чем тремя живыми соседями умирает, как будто из-за перенаселения.
 * 
 * Любая мертвая клетка с ровно тремя живыми соседями становится живой клеткой, как будто из-за размножения.
 * 
 * Следующее состояние доски определяется путем одновременного применения вышеуказанных правил к каждой ячейке 
 * в текущем состоянии доски сетки m x n. В этом процессе рождение и смерть происходят одновременно.
 * Учитывая текущее состояние доски, обновите доску, чтобы отразить ее следующее состояние.
 * Обратите внимание, что вам не нужно ничего возвращать.
 */

import static org.junit.Assert.assertArrayEquals;

import org.junit.jupiter.api.Test;

public class GameOfLife {

	public void gameOfLife(int[][] board) {

	}

	public int liveNeighbors(int[][] board, int m, int n, int i, int j) {
		int count = 0;
		for (int x = Math.max(0, i - 1); x < Math.min(m, i + 1); ++x) {
			for (int y = Math.max(0, j - 1); y < Math.min(n, j + 1); ++y) {
				count += board[x][y] == 0 ? 0 : board[x][y];
			}
		}
		return count;
	}

	@Test
	public void case1() {
		int[][] actual = {{0, 1, 0}, {0, 0, 1}, {1, 1, 1}, {0, 0, 0}};

		int[][] expected = {{0, 0, 0}, {1, 0, 1}, {0, 1, 1}, {0, 1, 0}};
		gameOfLife(actual);

		assertArrayEquals(expected, actual);
	}

	@Test
	public void case2() {
		int[][] actual = {{1, 1}, {1, 0}};

		int[][] expected = {{1, 1}, {1, 1}};
		gameOfLife(actual);

		assertArrayEquals(expected, actual);
	}
}
